#!/usr/bin/env python3

import rospy
import particle_class as pars
import motion_model as motion
import sensor_model as sensor
import numpy as np

pose = Pose()
clicked = False
def Clicked(msg):
    global pose
    global clicked

    pose = msg.pose.pose
    clicked = True

if __name__=='__main__':
    rospy.init_node("mcl_p")

    # time interval, delta time
    delta_t = 0.02

    rate = rospy.Rate(1/delta_t)
    particleNum = 50
    particles = pars.Particles(particleNum)
    particles.InitParticles()

    motion_model = motion.MotionModel(delta_t)
    sensor_model = sensor.SensorModel()
    sub = rospy.Subscriber("/initialpose",PoseWithCovarianceStamped,Clicked,queue_size=10)

    counter = 0
    step = 1/particleNum

    particles.PublishParticles()
    rate.sleep()
    particles.PublishParticles()
    rate.sleep()
    particles.PublishParticles()
    while not rospy.is_shutdown():
        if counter == 100000:
            counter = 0
        if clicked == True:
            clicked = False

            # update measurement likelihood to particle weight
            for i in range(particleNum):
                particles.weight[i] = sensor_model.CorrectionOneParticle(particles.particleArray[i])

            normalizer = sum(particles.weight)
            for i in range(particleNum):
                particles.weight[i] = particles.weight[i]/normalizer

            # #####################
            # # resample particles#
            # #####################

            new_particles = []
            c = []
            c.append(particles.weight[0])
            n = particleNum
            for i in range(1,n):
                c.append(c[i-1]+particles.weight[0])
            u = np.random.uniform(0,1/n)
            i = 0
            end = False
            while end == False:
                while u>c[i]:
                    if i<n-1:
                        i+=1
                    else:
                        end = True
                        break
                new_particles.append(particles.particleArray[i])
                u+=1/n
            for _ in range(n-len(new_particles)):
                new_particles.append(particles.particleArray[n-1])
            particles.particleArray = new_particles


        # Motion Update
        for i in range(len(particles.particleArray)):
            particles.particleArray[i] = motion_model.PredictMotion(particles.particleArray[i])
        particles.PublishParticles()

        counter+=1
        rate.sleep()

